<!doctype html> <html> <head> <meta charset=utf-8 /> <meta http-equiv=X-UA-Compatible content="IE=edge;chrome=1"/> <meta name=viewport content="width=device-width"> <meta property="og:locale" content=en_us> <meta property="og:type" content=article> <meta property="og:title" content="Build a Chess AI Player"> <meta property="og:url" content="http://array.blue/blog/2014/chess-ai.html"> <meta property="article:published_time" content="2014-10-03T07:00:00Z"> <meta property="article:tag" content=ai> <meta property="article:tag" content=game> <title>[ Build a Chess AI Player ].blue</title> <link rel=alternate type="application/atom+xml" title="Atom Feed" href="/feed.xml"/> <link href="//fonts.googleapis.com/css?family=Montserrat:400,700" rel=stylesheet type="text/css" media="(min-width: 767px)"> <link href="/stylesheets/all-2548ef72.css" rel=stylesheet type="text/css"/> <script src="/javascripts/all-641b3993.js"></script> </head> <body class="blog blog_2014 blog_2014_chess-ai" itemscope itemtype="http://schema.org/Blog"> <div class=wrapper> <header class=page> <h1 itemprop=name><a href="/">[ ].blue</a></h1> <h6 itemprop=author>Blog of <span itemprop=givenName>Titus</span> <span itemprop=familyName>Stone</span></h6> </header> <main> <article itemprop=blogPost itemscope itemtype="http://schema.org/BlogPosting"> <h1 class=title itemprop=headline>Build a Chess AI Player</h1> <h4 class=date itemprop=dateCreated>October 3, 2014</h4> <div itemprop=articleBody> <p>I&#39;ve been doing a lot of algorithm-y things lately, and in particular a few co-workers have been working on some sudoku game implementations. As a result I&#39;ve ended up coding a few bits of sudoku code <a href="https://github.com/tstone/algorithms/blob/master/jvm/src/main/scala/sudoku/2DArray.scala">here</a> and <a href="https://github.com/tstone/algorithms/blob/master/jvm/src/main/java/algorithms/sudoku/2DArrayJ.java">there</a>. I also recently read through (most of) <em><a href="//amzn.com/0486678709">Introduction to Graph Theory</a></em> by Richard Trudeau.</p> <p>I came across a simple implementation of the game of 2-player chess in Ruby and it struck me that I could build an AI player for it. Not that I&#39;ve ever done anything previously with AI in my life, but with a lot of permutation generation and graph algorithms fresh in my mind I started to quickly conceive of how I might approach this.</p> <p>Without a doubt there are well-studied approaches as to how this should work already in existence. But I wanted to reason through it myself first. I&#39;ve found that often when I try to solve a problem myself, when I then do read up on already discovered solutions it&#39;s typically much easier for me to understand them as I&#39;m already familiar with the problem domain and can focus solely on the solution.</p> <p>In any case, here was my general strategy.</p> <p>At the top level was the notion of an &quot;AI Player&quot;. At any one point in time the ai player has only one piece of state: a move list (an array of moves). The move list is generated by a <code>Strategy</code>. In a nutshell, the &quot;AI&quot; part of all this is a simple algorithm to assess the state of the game. A decision will then be made to continue with the current move list or to use another strategy to generate a new move list.</p> <p>Assume a variable <code>game</code> is in scope which has three properties, <code>#board</code>: the game board as a 2D array; <code>#moves</code>: a list of all moves up to that point; and <code>#graveyard</code>: pieces that have been removed from the board (pieces active on the board would be available via <code>#board#pieces</code>).</p> <p>The ai player logic would be something simple like...</p> <div class=highlight><pre class="highlight ruby"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class=rouge-code><pre><span class="k">class</span> <span class="nc">AiPlayer</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@move_list</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">next_move</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">in_check?</span>
      <span class="vi">@move_list</span> <span class="o">=</span> <span class="no">DefensiveStrat</span><span class="p">.</span><span class="nf">determine_moves</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="o">!</span><span class="n">moves_left?</span> <span class="n">or</span> <span class="o">!</span><span class="n">next_move_is_valid?</span>
      <span class="vi">@move_list</span> <span class="o">=</span> <span class="n">choose_new_offense</span><span class="p">(</span><span class="n">game</span><span class="p">).</span><span class="nf">determine_moves</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="vi">@move_list</span><span class="p">.</span><span class="nf">shift</span><span class="p">()</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">choose_new_offense</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">game</span><span class="p">.</span><span class="nf">moves</span><span class="p">.</span><span class="nf">size</span> <span class="o">&lt;</span> <span class="mi">3</span>
      <span class="no">ScriptedOpeningStrat</span>
    <span class="k">elsif</span> <span class="n">games</span><span class="p">.</span><span class="nf">moves</span><span class="p">.</span><span class="nf">size</span> <span class="o">&lt;</span> <span class="mi">20</span>
      <span class="no">ControlBoardCenterStrat</span>
    <span class="k">else</span>
      <span class="no">ShortestPathToCheckStrat</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div> <p>Determining the next move is a matter of first seeing if the AI player is in check This could be expanded to see if the AI player is in check in N more moves as well. Next check if there are moves remaining in the current <code>@move_list</code> or if the next planned move from the <code>move_list</code> is now invalid for one reason or another. If either of these cases are true we&#39;ll need to select a new offensive strategy.</p> <p>I imagine offensive strategies fall into 3 buckets: repeat a scripted opening, try to control the center of the board by moving offensive pieces out, and finally figure out the shortest path to putting the enemy king in check.</p> <h3>ScriptedOpening</h3> <p>Thinking of openings as &quot;scripted&quot; is fairly close to how <a href="//en.wikipedia.org/wiki/Chess_opening">actual chess games</a> are played. There&#39;s not a lot of thought that happens except choosing which opening to go with. If the AI player is white, they can randomly picked from a pre-programmed list. If the AI player is black it can randomly pick from a smaller sub-set of possibilities based on the human player&#39;s first move, typically king or queen pawn.</p> <h3>ControlBoardCenterStrat</h3> <p>This is the first use of graph theory. The position a piece can be in is a vertex and the positions into can go to are also a vertex and the action of making that move is the edge. A breadth-first search of the imposed graph (moves/positions) would allow a search to go until either a center of the board was found or a certain number of moves was encountered. The latter restriction is because we don&#39;t want to have to have a piece hop all over taking 4 or 5 moves to control the center. We want it to be 1 or 2 moves away.</p> <p>Graph searching has some background but the A* algorithm is the general purpose workhorse for most applications. Red Blob Games has an excellent <a href="//www.redblobgames.com/pathfinding/a-star/introduction.html">Introduction to A*</a> which I highly recommend reading.</p> <p>Since the algorithm can be used in a number of places I was playing around with implementing it using a ruby block to capture the &quot;when to quit&quot; condition. This isn&#39;t fully-formed code but it conveys the idea:</p> <div class=highlight><pre class="highlight ruby"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class=rouge-code><pre><span class="k">def</span> <span class="nf">a_star</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">piece</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">frontier</span> <span class="o">=</span> <span class="no">Queue</span><span class="p">.</span><span class="nf">new</span>
  <span class="n">frontier</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">piece</span><span class="p">.</span><span class="nf">pos</span><span class="p">)</span>
  <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>
  <span class="n">visited</span><span class="p">[</span><span class="n">piece</span><span class="p">]</span> <span class="o">=</span> <span class="kp">true</span>

  <span class="n">current</span> <span class="o">=</span> <span class="n">frontier</span><span class="p">.</span><span class="nf">pop</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">frontier</span><span class="p">.</span><span class="nf">empty?</span> <span class="n">and</span> <span class="n">block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">frontier</span><span class="p">)</span>
    <span class="n">piece</span><span class="p">.</span><span class="nf">position</span> <span class="o">=</span> <span class="n">current</span>
    <span class="n">piece</span><span class="p">.</span><span class="nf">moves</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">possible_pos</span><span class="o">|</span>
      <span class="k">unless</span> <span class="n">visited</span><span class="p">.</span><span class="nf">has_key?</span><span class="p">(</span><span class="n">possible_pos</span><span class="p">)</span>
        <span class="n">frontier</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">possible_pos</span><span class="p">)</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">possible_pos</span><span class="p">]</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">frontier</span><span class="p">.</span><span class="nf">pop</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div> <p>The idea is that <code>&amp;block</code> is used to give the restrictions for the particular case we&#39;re interested in. For <code>ControlBoardCenterStrat</code> we might want to limit the number of moves to <code>2</code> and also stop if we&#39;ve found the center of the board. I imagine it would look like something to the effect of...</p> <div class=highlight><pre class="highlight plaintext"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class=rouge-code><pre>a_star(game.board, piece[0]) do |current_pos, visited, frontier|
  current_pos == "d4" or
  current_pos == "d5" or
  current_pos == "e4" or
  current_pos == "e5" or
  visited &gt; 2
end
</pre></td></tr></tbody></table></code></pre></div> <h3>ShortestPathToCheckStrat</h3> <p>This strategy is similar to <code>ControlBoardCenterStrat</code> except that it might have a priority list of pieces to try in order, say Rook, Queen, Bishop, and so on. For each piece it would attempt to use the same A* algorithm to find the shortest path to check, regardless of length. The strategy would choose the piece with the shortest path and execute that sequence, then try again with another piece. One trick would be to avoid using the same piece to place the player in check over and over. This could perhaps be it&#39;s own strategy, <code>AnnoyWithOneStepCheckStrat</code> or something along those lines.</p> <h2>Improvements</h2> <p>One thing I like about this approach is that there is a lot of room for improvements because of the separation between strategy implementation and choosing which strategy to run. It avoids trying to have a huge block of if/thens and handle all these odd cases. Even if you have two strategies that seemingly look alike, it makes more sense to have two strategies which each handle the nuance of their particularities.</p> <p>The <code>choose_offensive_strat</code> function is rather weak but easily improved.</p> <div class=highlight><pre class="highlight ruby"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class=rouge-code><pre><span class="k">def</span> <span class="nf">choose_new_offense</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">game</span><span class="p">.</span><span class="nf">moves</span><span class="p">.</span><span class="nf">size</span> <span class="o">&lt;</span> <span class="mi">3</span>            <span class="c1"># early game</span>
    <span class="no">ScriptedOpeningStrat</span>
  <span class="k">elsif</span> <span class="n">games</span><span class="p">.</span><span class="nf">graveyard</span><span class="p">.</span><span class="nf">size</span> <span class="o">&gt;=</span> <span class="mi">10</span>  <span class="c1"># late game</span>
    <span class="no">ShortestPathToCheckStrat</span>
  <span class="k">else</span>                              <span class="c1"># mid game</span>
    <span class="no">ControlBoardCenterStrat</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div> <p>Picking a strategy based number of moves is a fairly weak way to go. I considere the idea of an <code>Assessment</code> or a encapsulated way to analyze the board. For example, one assessment might be <code>ControlOfCenterAssessment</code> which returns an <code>influence</code> (number of pieces which are attacking a spot on the center of the board). Or another assessment might be <code>SelfPawnStructureAssessment</code> which returns an <code>influence</code> reflecting the number of pawns that are in an advantageous position. These could be used to make decisions about strategies instead of just something simple like the number of moves that have taken place.</p> <h2>OO</h2> <p>One thing I ran into which was less than stellar was that implementing the AI required me to &quot;explore the graph&quot; which is a fancy way of saying I needed to play out permutations of a board. Typically a graph is stored, at least by it&#39;s mathematical definition, as a set of vertices and a set of edges (which are themselves a 2 length set of vertices). Applying that to the game board there isn&#39;t quite a 1:1 alignment. Instead we have current position (starting vertex) and possible positions (neighboring vertices). The edges are inferred.</p> <p>Anyways, one thing I found was that to explore the graph I needed to create various modifications of the game board. However with Ruby&#39;s strong OO style the game board wasn&#39;t just a few pieces of data but a whole object that had a 2D array within it, where the values in the 2D array were instance of piece objects. From a Ruby perspective this makes a lot of sense. However with my intent to rapidly created 100&#39;s of these per move it didn&#39;t seem like a good plan.</p> <p>What I&#39;d like to investigate is representing the game board as a very lightweight 2D array that only contains primitives (each piece type is represented by a number, pawn is 1, rook is 2, etc.) This way I can quickly spin up a bunch of variations fast and then have a large variety of functions to apply towards them. In a real way I think I&#39;m preferring a funcitonal approach for this instead.</p> <h2>UI</h2> <p>The other reason I think I&#39;m going to move away from Ruby for this project is that ultimately I want to be able to attach some kind of nice presentation to all this. A console or Ruby GUI toolkit won&#39;t quite match what the browser gives now days. HTML, SVG, Canvas, and WebGL are all extremely accessible in browsers now days and for people like me who don&#39;t want to get into a really complex game engine it&#39;s a great way to get going fast without getting stuck in the weeds. Whatever solution I pick I think the web as a platform is the route I&#39;ll go.</p> <p>A minor hiccup in this regard is should I or should I not go with a UI toolkit. I&#39;d like to spend more time with Angular or Ember however i worry that their view model approach would bind my game implementation too much to the UI. In an ideal world the game would be implemented simply &quot;in memory&quot; and a presentation layer of HTML or SVG or whatever could just be &quot;bolted&quot; on the top after the fact without affecting the game.</p> </div> </article> </main> </div> <footer> <span>&copy; Titus Stone</span> <a href="/">Home</a> <a href="//github.com/tstone">Github</a> <a href="//twitter.com/andstuff">Twitter</a> </footer> <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-32115012-1', 'auto');
        ga('send', 'pageview');
      </script> </body> </html>